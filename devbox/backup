#!/usr/bin/env bash
set -euo pipefail

SCRIPT_NAME="machine backup"
DEFAULT_VAULT="Employee"
ITEM_TITLE_PREFIX="Devbox backup: "
DEVBOX_ITEM_NAME="devbox-config"

expand_path() {
  local p="$1"
  p="${p/#\$HOME/$HOME}"
  p="${p/#~/$HOME}"
  printf '%s\n' "$p"
}

require_tools() {
  if ! command -v op >/dev/null 2>&1; then
    echo "Error: 1Password CLI 'op' is required but not installed." >&2
    exit 1
  fi
  if ! command -v jq >/dev/null 2>&1; then
    echo "Error: jq is required but not installed." >&2
    exit 1
  fi
}

require_op_signin() {
  if ! op whoami >/dev/null 2>&1; then
    echo 'You must be signed in to 1Password CLI (run: eval "$(op signin)")' >&2
    exit 1
  fi
}

get_devbox_root() {
  printf '%s\n' "${DEVBOX_PROJECT_ROOT:-/home/roos/.local/share/devbox/global/default}"
}

get_devbox_config_path() {
  local root
  root="$(get_devbox_root)"
  printf '%s\n' "$root/devbox.json"
}

ensure_devbox_config_exists() {
  local cfg
  cfg="$(get_devbox_config_path)"
  if [[ ! -f "$cfg" ]]; then
    echo "Error: devbox.json not found at: $cfg" >&2
    exit 1
  fi
  printf '%s\n' "$cfg"
}

# Build a JSON array of backup configs, including a synthetic entry
# for devbox.json itself (name == DEVBOX_ITEM_NAME).
#   [
#     { "name": "devbox-config", "path": "<path>", "vault": "<vault>", "type": "file" },
#     ... contents of .backups[] ...
#   ]
build_effective_backups_json() {
  local config_path="$1"
  local devbox_path vault
  devbox_path="$(get_devbox_config_path)"
  vault="$DEFAULT_VAULT"

  # Synthetic entry for devbox.json itself
  local devbox_entry
  devbox_entry="$(jq -n \
    --arg name  "$DEVBOX_ITEM_NAME" \
    --arg path  "$devbox_path" \
    --arg vault "$vault" \
    '{name: $name, path: $path, vault: $vault, type: "file"}')"

  local backups_array
  backups_array="$(jq '.backups // []' "$config_path")"

  jq -n --argjson devbox "$devbox_entry" --argjson backups "$backups_array" '
    [$devbox] + $backups
  '
}

# Iterate over effective backups (devbox-config + .backups[]).
# Arguments:
#   $1 - path to config
#   $2 - (optional) name filter; if empty, process all
#   $3 - op type: "backup" or "restore"
process_backups() {
  local config_path="$1"
  local filter_name="${2:-}"
  local op_type="$3"

  local effective
  effective="$(build_effective_backups_json "$config_path")"

  local count
  count="$(jq 'length' <<<"$effective")"
  if [[ "$count" -eq 0 ]]; then
    echo "No backups defined (including devbox-config)." >&2
    return 0
  fi

  local processed=0
  for i in $(seq 0 $((count - 1))); do
    local name raw_path path vault type
    name="$(jq -r ".[$i].name" <<<"$effective")"
    raw_path="$(jq -r ".[$i].path" <<<"$effective")"
    vault="$(jq -r ".[$i].vault // \"$DEFAULT_VAULT\"" <<<"$effective")"
    type="$(jq -r ".[$i].type // \"file\"" <<<"$effective")"

    if [[ -z "$name" || "$name" == "null" ]]; then
      echo "Skipping index $i: missing 'name'." >&2
      continue
    fi

    # If filter_name is set, only process matching entry
    if [[ -n "$filter_name" && "$filter_name" != "$name" ]]; then
      continue
    fi

    processed=$((processed + 1))

    if [[ -z "$raw_path" || "$raw_path" == "null" ]]; then
      echo "Skipping '$name': missing 'path'." >&2
      continue
    fi

    path="$(expand_path "$raw_path")"
    local TITLE="${ITEM_TITLE_PREFIX}${name}"

    case "$op_type" in
      backup)
        do_single_backup "$name" "$path" "$vault" "$type" "$TITLE"
        ;;
      restore)
        do_single_restore "$name" "$path" "$vault" "$type" "$TITLE"
        ;;
      *)
        echo "Internal error: unknown op_type '$op_type'" >&2
        exit 1
        ;;
    esac
  done

  if [[ -n "$filter_name" && "$processed" -eq 0 ]]; then
    echo "No backup entry with name '$filter_name' (including devbox-config) found." >&2
    exit 1
  fi
}

# ---- single-item operations ---------------------------------------------

do_single_backup() {
  local name="$1"
  local path="$2"
  local vault="$3"
  local type="$4"
  local TITLE="$5"

  local file_to_upload

  if [[ "$type" == "directory" ]]; then
    if [[ ! -d "$path" ]]; then
      echo "Skipping '$name': directory not found: $path" >&2
      return
    fi

    echo "Backing up directory '$path' as '$TITLE' to vault '$vault'..."

    local tmpfile
    tmpfile="$(mktemp "/tmp/${name}.tar.gz.XXXXXX")"
    tar -czf "$tmpfile" -C "$(dirname "$path")" "$(basename "$path")"
    file_to_upload="$tmpfile"
  else
    if [[ ! -f "$path" ]]; then
      echo "Skipping '$name': file not found: $path" >&2
      return
    fi

    echo "Backing up file '$path' as '$TITLE' to vault '$vault'..."
    file_to_upload="$path"
  fi

  # Delete existing item with same title (if any)
  local existing_id
  existing_id="$(op item list --vault "$vault" --format json \
    | jq -r --arg title "$TITLE" '.[] | select(.title == $title) | .id' \
    | head -n1 || true)"

  if [[ -n "$existing_id" && "$existing_id" != "null" ]]; then
    op item delete "$existing_id" --vault "$vault" >/dev/null
  fi

  op document create "$file_to_upload" \
    --title "$TITLE" \
    --vault "$vault" \
    >/dev/null

  if [[ "$type" == "directory" && "$file_to_upload" == /tmp/${name}.tar.gz.* ]]; then
    rm -f "$file_to_upload"
  fi
}

do_single_restore() {
  local name="$1"
  local path="$2"
  local vault="$3"
  local type="$4"
  local TITLE="$5"

  local item_id
  item_id="$(op item list --vault "$vault" --format json \
    | jq -r --arg title "$TITLE" '.[] | select(.title == $title) | .id' \
    | head -n1 || true)"

  if [[ -z "$item_id" || "$item_id" == "null" ]]; then
    echo "Skipping '$name': no 1Password item titled '$TITLE' in vault '$vault'." >&2
    return
  fi

  echo "Restoring '$name' from '$TITLE' in vault '$vault'..."

  local parent_dir
  parent_dir="$(dirname "$path")"
  mkdir -p "$parent_dir"

  if [[ "$type" == "directory" ]]; then
    local tmpfile
    tmpfile="$(mktemp --dry-run "/tmp/${name}.tar.gz.XXXXXX")"
    op document get "$item_id" --vault "$vault" --out-file "$tmpfile"
    tar -xzf "$tmpfile" -C "$parent_dir"
    rm -f "$tmpfile"
  else
    op document get "$item_id" --vault "$vault" > "$path"
  fi
}

# ---- main ---------------------------------------------------------------

usage() {
  cat <<EOF
Usage:
  $SCRIPT_NAME create             Backup devbox.json and all configured items
  $SCRIPT_NAME restore            Restore devbox.json and all configured items
  $SCRIPT_NAME create <name>      Backup only the item with this config name
  $SCRIPT_NAME restore <name>     Restore only the item with this config name

Names refer to:
  - The synthetic entry "devbox-config" (devbox.json itself)
  - Or entries in devbox.json under .backups[].name

Special name:
  devbox-config
      Refers to the devbox.json itself. It is treated like a normal
      create entry and is always present, even if .backups[] is empty.

Examples:
  # Backup everything (devbox.json + all .backups[])
  $SCRIPT_NAME create

  # Restore everything (devbox.json + all .backups[])
  $SCRIPT_NAME restore

  # Backup only devbox.json
  $SCRIPT_NAME create devbox-config

  # Restore only devbox.json
  $SCRIPT_NAME restore devbox-config

  # Backup only the "ssh-config" entry from .backups[]
  $SCRIPT_NAME create ssh-config

  # Restore only the "gitconfig" entry from .backups[]
  $SCRIPT_NAME restore gitconfig

devbox.json location
--------------------
The script looks for devbox.json at:

  \$DEVBOX_PROJECT_ROOT/devbox.json
  or (if DEVBOX_PROJECT_ROOT is not set)
  /home/roos/.local/share/devbox/global/default/devbox.json

Configuration format for .backups[]
-----------------------------------
devbox.json may contain a "backups" array. Each element describes either a
single file or a directory to be backed up to 1Password as a Document:

{
  "backups": [
    {
      "name": "ssh-config",          // REQUIRED, unique identifier used in CLI
      "path": "\$HOME/.ssh",          // REQUIRED, file or directory path
      "vault": "Employee",           // OPTIONAL, 1Password vault name (default: "Employee")
      "type": "directory"            // OPTIONAL, "file" (default) or "directory"
    },
    {
      "name": "gitconfig",
      "path": "\$HOME/.gitconfig",
      "vault": "Employee",
      "type": "file"
    }
  ]
}

Fields
------
- name   (string, required)
- path   (string, required) â€” supports leading "\$HOME" or "~"
- vault  (string, optional; default "Employee")
- type   (string, optional; "file" (default) or "directory")

devbox.json itself
------------------
devbox.json is always part of the effective backup list as:

  {
    "name": "devbox-config",
    "path": "<resolved devbox.json path>",
    "vault": "Employee",
    "type": "file"
  }

You do NOT need to add devbox.json into .backups[].
EOF
}

main() {
  if [[ $# -lt 1 || $# -gt 2 ]]; then
    usage
    exit 1
  fi

  local action="$1"
  local filter_name="${2:-}"

  case "$action" in
    create|restore)
      ;;
    *)
      usage
      exit 1
      ;;
  esac

  require_tools
  require_op_signin

  local config_path
  if [[ "$action" == "create" ]]; then
    # For backup we require devbox.json to exist (devbox-config + .backups[])
    config_path="$(ensure_devbox_config_exists)"
    action=backup
  else
    # For restore a missing devbox.json is OK; but if it exists we use it.
    local cfg_path
    cfg_path="$(get_devbox_config_path)"
    if [[ -f "$cfg_path" ]]; then
      config_path="$cfg_path"
    else
      # If restoring and devbox.json doesn't exist yet, we still need a
      # minimal config file so build_effective_backups_json knows the path.
      # Create a temporary empty config with no .backups[].
      config_path="$(mktemp "/tmp/devbox-empty-config.XXXXXX.json")"
      printf '{"backups":[]}\n' >"$config_path"
    fi
  fi

  process_backups "$config_path" "$filter_name" "$action"

  echo "${action^} completed."
}

main "$@"
